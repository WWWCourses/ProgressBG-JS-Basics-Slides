<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>TypeScript_Basics</title>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
    <!-- css & themes include -->
    <link rel="stylesheet" href="../../../lib/reveal.js/dist/reset.css">
    <link rel="stylesheet" href="../../../lib/reveal.js/dist/reveal.css">
    <link rel="stylesheet" href="../../../outfit/css/themes/projector.css" id="theme">


    <!-- Theme used for syntax highlighting of code -->
    <!-- <link rel="stylesheet" href="../../../lib/reveal.js/plugin/highlight/zenburn.css"> -->

    <!-- custom -->
    <link rel="stylesheet" href="../../../outfit/css/reveal.js.css">
    <base target="_blank">
</head>
<body>
    <div class="reveal default center" data-transition-speed="default" data-background-transition="default">
        <div class="top_links">
            <a class="home_link" href="../../../index.html#TypeScript_Basics" target="_top"><i class="fa fa-home"></i></a>
            <span class="help_link"><i class="fa fa-question"></i></span>
            <div class="help_text">
                <div class="note">Keyboard shortcuts:</div>
                <div><span>N/Спейс</span><span>Next Slide</span></div>
                <div><span>P</span><span>Previous Slide</span></div>
                <div><span>O</span><span>Slides Overview</span></div>
                <div><span>ctrl+left click</span><span>Zoom Element</span></div>
                <div class="print-howto"><br>If you want print version => add '<code>?print-pdf</code>' <br> at the end of slides URL (remove '#' fragment) and then print. <br>
                Like: https://wwwcourses.github.io/...CourseIntro.html?print-pdf </div>
            </div>
        </div>
        <div class="footer theme_switch">
            <a href="#" onclick="document.getElementById('theme').setAttribute('href','../../../outfit/css/themes/dark.css'); return false;">Dark</a>
            <a href="#" onclick="document.getElementById('theme').setAttribute('href','../../../outfit/css/themes/light.css'); return false;">Light</a>
            <a href="#" onclick="document.getElementById('theme').setAttribute('href','../../../outfit/css/themes/projector.css'); return false;">Projector</a>
        </div>
        <div class="slides">
<!--
########################################################
##################### SLIDES START #####################
########################################################
-->
<section><h1>TypeScript Basics</h1></section>
<section data-transition="zoom">
    <section>
        <div class="copyright">
            <div class="note">
                <p>Created for</p>
            </div>
            <div class="company">
                <a href="https://progressbg.net/javascript-basic/">
                <img src="../../../outfit/images/logos/ProgressBG_logo_529_127.png" alt="ProgressBG_logo">
                </a>
            </div>
        </div>
    </section>
    <section class="copyright" data-transition="zoom" style="margin-top: -2em;">
        <div class="note">
            <p>Created by</p>
        </div>
        <div class="company">
           <div class="LI-profile-badge"  data-version="v1" data-size="large" data-locale="en_US" data-type="vertical" data-theme="dark" data-vanity="ivapopova"><a class="LI-simple-link" href="https://bg.linkedin.com/in/ivapopova?trk=profile-badge">Iva E. Popova</a></div>
        </div>
        <!-- <div class="author">
            <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a>
        </div> -->
    </section>
</section>



<section data-min="10"><h1>TypeScript Overview</h1></section>
<section><h2>TypeScript Overview</h2>
    <section><h3>Overview</h3>
        <dl class="fa">
            <dl class="fa">
                <dt>TypeScript is a <b>superset</b> of JavaScript, which means <span class="note">each valid JavaScript program is a valid TypeScript program</span>.</dt>
                <a href="images/ES5-ES6-TS.png"><img src="images/ES5-ES6-TS.png"></a>
                <dt>TypeScript compiles to clean, simple JavaScript code which runs on any browser, in Node.js, or in any JavaScript engine that supports ECMAScript 3 (or newer).</dt>
                <dt>official site: <a href="https://www.typescriptlang.org/index.html">typescriptlang.org</a></dt>
            </dl>
        </dl>
    </section>
    <section><h3>Installation</h3>
        <pre><code rel="Terminal" class="bash" data-noescape>
            # install as global node module:
            $ sudo npm install -g typescript

            # check installation
            $ tsc -v
                Version 3.8.3
        </code></pre>
    </section>
    <section style="font-size: .8em"><h3>Usage</h3>
        <dl class="fa">
            <dt>We can transpile TypeScript (or ES6) to ES5 using the TypeSctipt compiler</dt>
            <dt>Let's have a valid ES6 file:</dt>
            <pre><code rel="ES6toES5.js" class="ts" style="height: 80vh;">
                class Animal {
                    name:string

                    constructor(name) {
                        this.name = name;
                    }

                    eat(){
                        console.log(`${this.name} is eating`);
                    }

                    speak() {
                        console.log(`${this.name} makes an animal noise`);
                    }
                }

                class Dog extends Animal {
                    constructor(name) {
                        super(name);
                    }

                    speak() {
                        console.log(`${this.name} barks`);
                    }
                }

                var pluto = new Dog('Pluto');

                pluto.speak();
                pluto.eat();
            </code></pre>
            <dt>We can transpile it to ES5 just by changing its extension to <span class="note">.ts</span> and:</dt>
            <pre><code rel="Terminal" class="bash" data-noescape>
                tsc ES6toES5.ts
            </code></pre>
        </dl>

    </section>
    <section><h3>TypeScript Features</h3>
        <dl class="fa">
            <dt>Static typing</dt>
            <dt>Interfaces</dt>
            <dt>Decorators</dt>
            <dt>Transpile into old ES version</dt>
            <dt>many others...</dt>
        </dl>
    </section>
    <section><h3>Static Typing vs Dynamic typing</h3>
        <dl class="fa">
            <dt>In dynamically typed languages(JavaScript, Python, PHP, Ruby...) types of variables are generally not known at compile time.</dt>
            <dt>In a statically typed language, variables, parameters, and objects members (i.e properties and methods) have types that the compiler knows at compile time.</dt>
            <dt>The compiler use that information to perform type checks and to optimize the compiled code.</dt>
            <dt class="note">TypeScript introduces static types into JavaScript!</dt>
        </dl>
    </section>

    <section><h3>The Benefits of Static Typing</h3>
        <dl class="fa">
            <dt><span class="note">Catch more errors at compile time</span> (and less bugs at run time)</dt>
            <dt>It helps IDEs with <span class="note">code-completion (IntelliSense)</span></dt>
            <dt>Type annotations are useful for <span class="note">documentation</span>, which helps large teams to collaborate</dt>
            <dt>Static Typing in JavaScript makes it less "ugly" for developers coming from Java, #C, and so on.</dt>
        </dl>
    </section>
    <section><h3>Early errors/bug finding</h3>
        <dl class="fa">
            <dt>TypeScript can help us to discover errors and bug-candidates while we write the program:</dt>
        </dl>
        <pre><code rel="TS" class="ts">
            let add = function(x,y) {
                console.log(x+y)
            }

            // this is legal JS call, but TypScript will raise an error:
            add(3);

            //test.ts(5,1): error TS2554: Expected 2 arguments, but got 1.
        </code></pre>
        <dl class="fa">
            <dt class="note">Note, that despite the error, the JS files is generated.</dt>
        </dl>
    </section>
</section>

<section data-min="10"><h1>Setup TypeScript Project</h1></section>
<section><h2>Setup TypeScript Project</h2>
    <section><h3>Prepare project folder structure</h3>
        <p>Create next folder structure for your TypeScript Demo Project:</p>
        <pre><code rel="Folder structure" class="bash">
            ts_demo_project/
            ├── dist
                # the compiled JS files
            └── src
                # for source TS files
        </code></pre>
    </section>
    <section><h3>Init the project (Create <code>package.json</code> with npm)</h3>
        <dl class="fa">
            <dt>The <code>package.json</code> file holds various metadata relevant to the project.</dt>
            <dt>Reference: <a href="https://nodejs.org/en/knowledge/getting-started/npm/what-is-the-file-package-json/">What is the file `package.json`?</a></dt>
            <dt>The command <code>npm init</code> is interactive, i.e. it will ask you question about the project providing sensible defaults.</dt>
            <dd>If you want to skip questions, and use the defaults, you can use the -f option. I.e. <code>npm init -y</code></dd>
        </dl>
        <pre><code rel="Terminal" class="bash">
            cd ts_demo_project
            npm init
        </code></pre>
    </section>
    <section><h3>Create <code>package.json</code> </h3>
        <p>Add the next script command to <code>package.json</code></p>
        <pre><code rel="package.json" class="bash">
            "scripts": {
                "build": "tsc",
                "start": "tsc -w"
            },
        </code></pre>
        <dl class="fa" style="min-width:80vw">
            <dt><code>build</code> command will compiles TypeScript files once.</dt>
            <dt><code>start</code> command will run the TypeScript compiler in watch mode, automatically recompiling on file changes..</dt>
        </dl>
    </section>
    <!-- <section><h3>Install project dependencies</h3>
        <dl class="fa">
            <dt>For the development of our project, we will use next node packages</dt>
        </dl>
        <pre><code rel="Terminal" class="bash">
            npm install --save-dev webpack webpack-cli
            npm install --save-dev typescript ts-loader source-map-loader
        </code></pre>
        <dl class="fa">
            <dt><span class="note">webpack</span> is a tool that will bundle your code and optionally all of its dependencies into a single .js file.</dt>
            <dt><span class="note">ts-loader</span> helps Webpack to compile your TypeScript code using the TypeScript’s standard configuration file (tsconfig.json)</dt>
            <dt><span class="note">source-map-loader</span> is useful for debugging</dt>
        </dl>
    </section> -->
    <section><h3>Create <code>tsconfig.json</code> file</h3>
        <dl class="fa">
            <dt>The tsconfig.json contains the TypeScript compiler options for our project.</dt>
            <dt>Reference: <a href="https://www.typescriptlang.org/docs/handbook/tsconfig-json.html">What is a tsconfig.json?</a></dt>
        </dl>
        <pre><code rel="Terminal" class="bash">
            # make sure you are in the root project folder:
            pwd
            # .../ts_demo_project

            # create the tsconfig.json with default settings
            tsc --init
        </code></pre>
    </section>
    <section><h3>Modify <code>tsconfig.json</code> file</h3>
        <dl class="fa" style="min-width:80vw">
            <dt>Open the generated tsconfig.json file and modify it according to your project needs. Here's a sample configuration:</dt>
            <pre><code rel="tsconfig.json" class="bash">
                {
                    "compilerOptions": {
                        "target": "ES6",                       // Specify ECMAScript target version
                        "module": "ES6",                  	   // Specify module code generation
                        "moduleResolution": "node",   		   // Resolve modules using Node.js-style resolution
                        "esModuleInterop": true,			   // Enable compatibility with CommonJS modules
                        "outDir": "./dist",                    // Redirect output structure to the 'dist' directory
                        "rootDir": "./src",                    // Specify the root directory of input files
                        "strict": true,                        // Enable all strict type-checking options
                    },
                    "include": ["src/**/*.ts"],                	// Specify files to include
                    "exclude": ["node_modules", "**/*.spec.ts"] // Specify files to exclude
                }
            </code></pre>

        </dl>
    </section>
    <section><h3>Create a simple TS file</h3>
        <dl class="fa">
            <dt>As we set TS compiler to look for ts files in ./src/ folder, we must have at least one, before starting the compiler. Otherwise an error: "error TS18003: No inputs were found in config file ..." will be raised.</dt>
            <dt>Create the <code>helloUser.ts</code> in <code>src/</code> folder</dt>
        </dl>
        <pre><code rel="ts_demo_project/src/helloUser.ts" class="ts">
            let userName='Ada';
            let userAge=34;

            console.log(`Hello ${userName}, you are ${userAge} age old`);

        </code></pre>
    </section>
    <section><h3>start the project</h3>
        <dl class="fa">
            <dt>write in your terminal:</dt>
        </dl>
        <pre><code rel="Terminal" class="bash">
            # make sure you're in the root project folder:
            pwd

            # start the project
            npm start
        </code></pre>
        <dl class="fa">
            <dt>Now ts will compile each 'ts' file in <code>src/</code> folder into respective file in <code>dist/</code> folder. And that will happen on every change.</dt>
        </dl>
    </section>
</section>

<section data-min="10"><h1>Basic Types in TypeScript</h1></section>
<section data-min="10"><h2>Basic Types in TypeScript</h2>
    <section><h3>TypeScript Types</h3>
        <dl class="fa">
            <dt>JavaScript have several native types, which also exist in TypeScript</dt>
            <dd><span class="note">boolean</span> - true/false</dd>
            <dd><span class="note">number</span> - integers, floats, Infinity and NaN</dd>
            <dd><span class="note">[]</span> - arrays of other types</dd>
            <dd><span class="note">{}</span> - object literal</dd>
            <dd><span class="note">undefined</span> - for not set value</dd>
            <dt>But TypeScript also adds:</dt>
            <dd><span class="note">enum</span> -  enumerations like { Red, Blue, Green }</dd>
            <dd><span class="note">any</span> -  use any type</dd>
            <dd><span class="note">void</span> - nothing</dd>
        </dl>
        <p>Reference: <a href="https://www.typescriptlang.org/docs/handbook/basic-types.html">Basic Types @typescriptlang.org</a></p>
    </section>
    <section><h3>Typing - examples</h3>
        <pre><code rel="TS" class="ts" style="font-size: 1em; min-height: 70vh;" data-copy>
            let start: boolean = false;
            let age: number = 16;
            let userName: string = "Ada";
            let dataList: number[] = [1, 2, 3];

            enum Color {Red, Green, Blue};
            let c: Color = Color.Green;

            let anything: any = 42;
            anything = "now I'm a string";
            anything = false;

            function showMessage(msg: string): void {
                console.log(msg);
            }
            showMessage('Howdy!');
        </code></pre>
    </section>
    <section><h3>Function Types</h3>
        <dl class="fa">
            <dt>We can add types to <span class="note">each of the parameters</span> and to the function's <span class="note">return type</span>.</dt>
            <dt>TypeScript can figure the return type out by looking at the return statements, so we can also optionally leave this off in many cases.</dt>
        </dl>
        <pre><code rel="TS" class="ts">
            function add(x: number, y: number): number {
                        return x + y;
            }

            console.log( add(2,3) );
        </code></pre>
    </section>
    <section><h3>Function Optional Parameters</h3>
        <pre><code rel="TS" class="ts">
            // optional parameters:
            function greet(firstName: string, lastName?: string) {
                return lastName? `${firstName} ${lastName}`: firstName;
            }

            console.log( greet('Ada', 'Byron') );
            console.log( greet('Ada') );
        </code></pre>
    </section>
</section>

<section data-min="5"><h1>Classes in TS</h1></section>
<section data-min="5"><h2>Classes</h2>
    <section><h3>Overview</h3>
        <dl class="fa">
            <dt>In TypeScript we define classes similarly to the ES6 class syntax.</dt>
            <dt>But in TypeScript <span class="note">public parameters in a constructor is a shorthand to automatically create properties with that name</span>.</dt>
        </dl>
        <pre><code rel="TS" class="typescript">
            class Person {
                name:string

                constructor(public firstName: string, public surName: string) {
                    // no need for: this.firstName = firstName
                    this.name = `${this.firstName} ${this.surName}`
                }
            }
        </code></pre>
    </section>
    <section><h3>Inheritance</h3>
        <dl class="fa">
            <dt>All properties and methods defined in parent class are inherited from the derived class.</dt>
            <dt>Each derived class that contains a constructor function <span class="note">must call</span> the super() constructor</dt>
        </dl>
        <pre><code rel="TS" class="typescript" style="font-size: .8em">
            class Person {
                name: string

                constructor(public firstName: string, public surName: string) {
                    this.name = `${this.firstName} ${this.surName}`;
                }

                greet(){
                    console.log(`Hello, my name is ${this.name}.`)
                }
            }

            class Student extends Person{
                college: string

                constructor(firstName: string, surName: string, college:string){
                    super(firstName, surName);
                    this.college=college;
                }

                greet(){
                    // if we want we can reuse the parent's greet() method (if we want to extend it)
                    super.greet();
                    console.log(`I study in ${this.college}`)

                    // or just to overwrite it
                }
            }

            let maria = new Person("Maria", "Popova");
            let ivan = new Student("Ivan", "Ivanov", 'TU-Sofia');

            maria.greet();
            ivan.greet();
        </code></pre>
    </section>
    <section><h3>Reference: <a href="https://www.typescriptlang.org/docs/handbook/classes.html">Classes @typescriptlang.org</a></h3></section>
</section>


<section data-min="5"><h1>Interfaces</h1></section>
<section data-min="5"><h2>Interfaces</h2>
    <section><h3>Overview</h3>
        <dl class="fa">
            <dt>An interface is an abstract type, i.e. it does not contain any executable code as a class does.</dt>
            <dt>An interface is a way to define a contract on a function with respect to the arguments and their type.</dt>
            <dt>Interface = Obligation</dt>
            <dt>An interface can also be used with a Class to define custom types.</dt>
        </dl>
    </section>
    <section><h3>An Interface did not generate code</h3>
        <dl class="fa">
            <dt>Next TypeScript code will note generate any JS code</dt>
        </dl>
        <pre><code rel="TS" class="ts">
            interface Point{
                x:number,
                y:number
            }
        </code></pre>
    </section>
    <section><h3>Interface to enforce a shape of an object</h3>
        <dl class="fa">
            <dt>Next code has a potential bug, as we did not enforce the shape of the object being passed</dt>
        </dl>
        <pre><code rel="TS" class="ts">
            function drawPoint(obj:any) {
                console.log(obj.x, obj.y);
            }

            drawPoint({
                x:1,
                y:2,
                z:3
            })
            // 1 2
            // no error is generated!
        </code></pre>
    </section>
    <section><h3>Interface to enforce a shape of an object</h3>
        <dl class="fa">
            <dt>We need to enforce an object shape for the drawPoint() parameter. An Interface is useful for that.</dt>
        </dl>
        <pre><code rel="TS" class="ts" style="min-height: 70vh;" data-copy>
            interface Point{
                x:number,
                y:number
            }

            function drawPoint(point:Point) {
                console.log(point.x, point.y);
            }

            drawPoint({
                x:1,
                y:2,
                z:3
            })
            // Error: Argument of type '{ x: number; y: number; z: number; }' is not assignable to parameter of type 'Point'. Object literal may only specify known properties, and 'z' does not exist in type 'Point'.
        </code></pre>
    </section>
    <section><h3>A class as an interface</h3>
        <dl class="fa">
            <dt>A class declaration in TypeScript creates two things: <span class="note">a type</span> representing instances of the class and <span class="note">a constructor function</span></dt>
            <dt>Consider next example and the error that throws:</dt>
        </dl>
        <pre><code rel="TS" class="ts" style="min-height: 90vh;" data-copy>
            class Duck{
                constructor(public name:string) {}
                quacks(){}
                swim(){}
            }

            class Cat {
                constructor(public name:string) {}
                quacks(){}
            }


            function isItDuck(obj:Duck) {
                obj.quacks?
                    console.log(`${obj.name} is a Duck`) :
                    console.log(`Not a Duck`);
            }

            let donald = new Duck('Donald');
            let tom = new Cat('Tom');

            isItDuck(donald);
            isItDuck(tom);
            //Argument of type 'Cat' is not assignable to parameter of type 'Duck'.
            Property 'swim' is missing in type 'Cat' but required in type 'Duck'.
        </code></pre>
    </section>
    <!-- <section><h3 class="advanced">Duck-typing</h3>
        <dl class="fa">
            <dt>In dynamic taping languages, the type of the object is determined by it's  <span class="note">shape</span> (set of properties and methods) and this is called "Duck-typing"</dt>
            <dd><q>If it looks like a duck, swims like a duck, and quacks like a duck, then it probably is a duck.</q></dd>
            <dt>In TypeScript, interfaces can create duck-typing.</dt>
        </dl>
        <pre><code rel="TS" class="ts" style="min-height: 90vh;" data-copy>
            export {};

            interface IDuck{
                name: string
                quacks():void
            }

            class Duck implements IDuck{
                constructor(public name:string) {}

                quacks(){}
                swim(){}
            }

            class Cat {
                constructor(public name:string) {}

                quacks(){}
            }


            function isItDuck(obj:IDuck) {
                obj.quacks?
                    console.log(`${obj.name} is a Duck`):
                    console.log(`Not a Duck`);
            }

            let donald = new Duck('Donald');
            let tom = new Cat('Tom');

            isItDuck(donald);
            isItDuck(tom);
        </code></pre>
    </section> -->
    <section><h3>Interfaces - example 1</h3>
        <pre><code rel="TS" class="ts">
            &quot;use strict&quot;;
            interface IDog{
                name: string,
                speak: ()=&gt;void
            }

            var pluto: IDog = {
                name:&quot;Pluto&quot;,
                speak: ()=&gt;console.log(&quot;I&#39;m &quot;+pluto.name)
            }

            pluto.speak();
        </code></pre>
    </section>
    <!-- <section><h3>Interfaces - example 2</h3>
        <pre><code rel="TS" class="ts">
            interface Callback {
                (data: any): void;
            }

            function getData(callback: Callback) {
                callback('Do something with data');
            }

            getData( (data) =&gt; console.log(data) ); // OK

            getData("Do something else with data")
            // error TS2345: Argument of type '"Do something else with data"' is not assignable to parameter of type 'Callback'
        </code></pre>
    </section> -->
</section>

<section><h1>Using ES6 Modules with TypeScript</h1></section>
<section><h2>Using ES6 Modules with TypeScript</h2>
    <section><h3>Overview</h3>
        <dl class="fa">
            <dt>TypeScript supports ES6-style modules, where we can use <code>import</code> and <code>export</code> to organize code across multiple files.</dt>
            <dt><span class="note">The ES6 module system allows for better code organization, modularity, and reusability.</span></dt>
            <dt>Reference: <a href="https://www.typescriptlang.org/docs/handbook/modules.html">Modules @typescriptlang.org</a></dt>
        </dl>
        <pre><code rel="TS" class="typescript">
            // greet.ts
            export function greet(name: string): string {
                return `Hello, ${name}!`;
            }
        </code></pre>
        <pre><code rel="TS" class="typescript">
            // main.ts
            import { greet } from './greet';

            const message = greet('World');
            console.log(message);  // Output: Hello, World!
        </code></pre>
    </section>
    <section><h3>Module Resolution in TypeScript</h3>
        <dl class="fa">
            <dt>TypeScript automatically resolves modules by examining the file path and settings defined in the <code>tsconfig.json</code> configuration file.</dt>
            <dt><span class="note">When working with ES6 modules, TypeScript can resolve imports without the need to specify file extensions, simplifying the import process.</span></dt>
            <dt>In browsers, you generally need to include the file extensions in your imports, e.g., import { someFunc } from './utils.js'; because the browser needs to know the exact file type. TypeScript won't handle this automatically unless you use a bundler.</dt>
            <dt>TypeScript uses different strategies for module resolution depending on the configuration in <code>tsconfig.json</code>, especially the <code>moduleResolution</code> setting.</dt>
        </dl>
        <pre><code rel="TS" class="typescript" style="font-size: .9em">
            // tsconfig.json example
            {
                "compilerOptions": {
                    "target": "ES6",             // Specifies the ECMAScript version for the compiled output
                    "module": "ES6",             // Tells TypeScript to use ES6 module syntax (import/export)
                    "moduleResolution": "node",  // Resolves modules using Node.js-style resolution (useful for working with Node.js),
                    "esModuleInterop": true      // Enables compatibility between ES6 and CommonJS modules for smoother imports
                }
            }
        </code></pre>
    </section>

    <section><h3>Importing and Exporting</h3>
        <dl class="fa">
            <dt><code>export</code> is used to make variables, functions, or classes available for other files to import.</dt>
            <dt><code>import</code> allows you to access the exported members from another file.</dt>
        </dl>
        <pre><code rel="TS" class="typescript">
            // math.ts
            export function add(a: number, b: number): number {
                return a + b;
            }

            // main.ts
            import { add } from './math';

            console.log(add(2, 3));  // Output: 5
        </code></pre>
    </section>
</section>

<section><h1>Generics in TypeScript</h1></section>
<section><h2>Generics in TypeScript</h2>
    <section><h3>Overview</h3>
        <dl class="fa">
            <dt>Generics allow you to write flexible, reusable code that can work with any data type while maintaining type safety.</dt>
            <dt><span class="note">They enable you to create components, functions, and classes that can work with any data type, making your code more versatile and adaptable.</span></dt>
            <dt>Reference: <a href="https://www.typescriptlang.org/docs/handbook/generics.html">Generics @typescriptlang.org</a></dt>
        </dl>
    </section>
    <section><h3>Basic Usage</h3>
        <dl class="fa">
            <dt>Generics allow you to define a placeholder for a data type that can be specified when the function, class, or interface is used.</dt>
        </dl>
        <pre><code rel="TS" class="typescript">
            // Function that takes an argument of any type and returns the same type
            function identity&lt;T&gt;(arg: T): T {
                return arg;
            }

            const output1 = identity&lt;string&gt;(&quot;Hello&quot;);
            const output2 = identity&lt;number&gt;(42);
        </code></pre>
    </section>
    <section><h3>Generic Constraints</h3>
        <dl class="fa">
            <dt>Generics can be constrained to specific types by using <code>extends</code>, ensuring the generic type meets certain requirements.</dt>
        </dl>
        <pre><code rel="TS" class="typescript">
            // Function that accepts a type which extends { length: number }
            function logLength&lt;T extends { length: number }&gt;(arg: T): void {
                console.log(arg.length);
            }

            logLength([1, 2, 3]); // Output: 3
            logLength(&quot;Hello!&quot;);   // Output: 6
        </code></pre>
    </section>
    <!-- <section><h3>Using Generics with Interfaces</h3>
        <dl class="fa">
            <dt>You can use generics with interfaces to define reusable types for objects or functions.</dt>
        </dl>
        <pre><code rel="TS" class="typescript">
            // Generic interface for a box that holds any type of item
            interface Box<T> {
                value: T;
            }

            const stringBox: Box<string> = { value: "Hello, World!" };
            const numberBox: Box<number> = { value: 123 };
        </code></pre>
    </section>
    <section><h3>Generics in Classes</h3>
        <dl class="fa">
            <dt>Generics can also be applied to classes to define types for properties or methods that can vary.</dt>
        </dl>
        <pre><code rel="TS" class="typescript">
            // Generic class that holds a value of any type
            class Container<T> {
                value: T;
                constructor(value: T) {
                    this.value = value;
                }
            }

            const stringContainer = new Container("Hello!");
            const numberContainer = new Container(42);
        </code></pre>
    </section> -->
</section>

<section><h1>The Omit&lt;&gt; utility type</h1></section>
<section><h2>The Omit&lt;&gt; utility type</h2>
    <section><h3>Overview</h3>
        <dl class="fa">
            <dt><code>Omit&lt;&gt;</code> is a utility type in TypeScript that creates a new type by removing one or more properties from an existing type.</dt>
            <dt><span class="note">It is helpful when you need to exclude properties from a type, such as in cases where you want a partial representation of an object.</span></dt>
        </dl>
    </section>

    <section><h3>Syntax</h3>
        <pre><code class="typescript">
            Omit&lt;Type, Keys&gt;
        </code></pre>
        <dl class="fa">
            <dt><code>Type</code> refers to the original type from which properties will be omitted.</dt>
            <dt><code>Keys</code> is the property or properties to remove (can be a single key or a union of keys).</dt>
        </dl>
    </section>

    <section><h3>Example</h3>
        <pre><code class="typescript">
            // Defining a Todo interface
            interface Todo {
            id: number;
            title: string;
            completed: boolean;
            }

            // Creating a new type that omits the 'id' property
            type TodoWithoutId = Omit&lt;Todo, 'id'&gt;;

            // Now we can create a TodoWithoutId object
            const todo: TodoWithoutId = {
            title: 'Learn TypeScript',
            completed: false,
            };
        </code></pre>
        <dl class="fa">
            <dt>In this example, the type <code>TodoWithoutId</code> has the same properties as <code>Todo</code> but without the <code>id</code> property.</dt>
        </dl>
    </section>

    <section><h3>Common Use Cases</h3>
        <ul>
            <li><strong>Excluding properties:</strong> When you need a type that is similar to another but without certain fields.</li>
            <li><strong>Partial updates:</strong> When you want to update an object but not modify all its properties.</li>
        </ul>
    </section>
</section>



<section><h1>Type Casting in TypeScript</h1></section>
<section><h2>Type Casting in TypeScript</h2>
    <section><h3>Overview</h3>
        <dl class="fa">
            <dt>Type casting is used to convert a variable from one type to another, either explicitly or implicitly.</dt>
            <dt><span class="note">In TypeScript, type casting allows you to tell the compiler about the type of a value, even if the compiler cannot infer it automatically.</span></dt>
            <dt>Reference: <a href="https://www.typescriptlang.org/docs/handbook/basic-types.html#type-assertions">Type Assertions @typescriptlang.org</a></dt>
        </dl>
    </section>
    <section><h3>Implicit Type Casting</h3>
        <dl class="fa">
            <dt>TypeScript automatically performs type casting when the source and target types are compatible.</dt>
        </dl>
        <pre><code rel="TS" class="typescript">
            let someNumber = 5;       // TypeScript infers type number
            let someString = "Hello"; // TypeScript infers type string

            let result = someNumber + 2;  // Implicitly treated as number
            let greeting = someString + " World!"; // Implicitly treated as string
        </code></pre>
    </section>
    <section><h3>Explicit Type Casting</h3>
        <dl class="fa">
            <dt>When TypeScript cannot automatically infer the correct type, explicit casting can be used to manually specify the type.</dt>
        </dl>
        <pre><code rel="TS" class="typescript">
            let someValue: any = "This is a string!";
            let stringLength: number = (someValue as string).length; // Using 'as' syntax

            let anotherValue: any = "123";
            let numberValue: number = <number><any>anotherValue; // Using angle-bracket syntax
        </code></pre>
    </section>
    <section><h3>Type Assertions</h3>
        <dl class="fa">
            <dt>Type assertions are a way to tell TypeScript about the type of a value, without performing any special checking or restructuring.</dt>
            <dt><span class="note">This does not change the type of the value at runtime, it is only for compile-time type-checking.</span></dt>
        </dl>
        <pre><code rel="TS" class="typescript">
            // Type assertion with 'as' keyword
            let someElement = document.querySelector("#my-element") as HTMLDivElement;
            someElement.style.backgroundColor = "red";

            // Type assertion with angle-bracket syntax
            let anotherElement = <HTMLDivElement>document.querySelector("#another-element");
            anotherElement.style.color = "blue";
        </code></pre>
    </section>
    <section><h3>When to Use Type Casting</h3>
        <dl class="fa">
            <dt>Type casting is useful when working with values of <code>any</code> type or when TypeScript can't infer the type automatically.</dt>
            <dt><span class="note">Be cautious, as incorrect type casting can lead to runtime errors if the actual type does not match the expected type.</span></dt>
        </dl>
    </section>
</section>




<section data-min="1"><h1>References</h1></section>
<section><h2>References</h2>
    <section><h3>Readings</h3>
        <dl class="fa">
            <dt><a href="https://code.visualstudio.com/docs/languages/typescript">TypeScript in Visual Studio Code</a></dt>
            <dt><a href="https://www.typescriptlang.org/docs/home.html">Documentation @typescriptlang.org</a></dt>
        </dl>
    </section>
</section>


<section data-min="5" id="HW"><h1>Exercises</h1></section>
<section><h2>Exercises</h2>
    <section><h3>Exercises</h3>
        <dl class="fa" style="min-width:80vw">
            <dt>The tasks are given in next file. You can copy it and work directly on it.</dt>
            <dt>Just put your code under "// YOUR CODE HERE" section.</dt>
            <pre><code rel="TS_tasks.ts" class="ts" style="min-height: 90vh;" data-copy>
                // TS_tasks.ts
                // ---------------------------------- Task 1 ---------------------------------- //
                    /* DESCRIPTION:
                    Write a function named `squareNumber` that takes a number as an argument and returns its square.
                    Ensure the argument is typed as a number.
                    */

                    // YOUR CODE HERE

                    // TEST
                    console.log(squareNumber(5));  // Expected output: 25
                    console.log(squareNumber(2.5));  // Expected output: 6.25

                // ---------------------------------- Task 2 ---------------------------------- //
                    /* DESCRIPTION:
                    Write a function named `isOdd` that takes a number as an argument and
                    returns true if the number is odd, and false if it is even. Type the argument correctly.
                    */

                    // YOUR CODE HERE

                    // TEST
                    console.log(isOdd(5));  // Expected output: true
                    console.log(isOdd(4));  // Expected output: false

                // ---------------------------------- Task 3 ---------------------------------- //
                    /* DESCRIPTION:
                    Create a class `Car` with the following properties:
                      - `make`: a string representing the car's make.
                      - `model`: a string representing the car's model.
                      - `year`: a number representing the car's manufacturing year.
                    Add a method `getCarInfo()` that returns a string with the car's details.
                    */

                    // YOUR CODE HERE


                    // TEST
                    const car1 = new Car("Toyota", "Corolla", 2020);
                    console.log(car1.getCarInfo());  // Expected output: "2020 Toyota Corolla"

                // ---------------------------------- Task 4 ---------------------------------- //
                    /* DESCRIPTION:
                    Create a class `Person` with the following properties:
                      - `firstName`: a string.
                      - `lastName`: a string.
                      - `age`: a number.
                    Add a method `introduce()` that returns a string introducing the person by their full name and age.
                    */

                    // YOUR CODE HERE


                    // TEST
                    const person1 = new Person("Alice", "Johnson", 30);
                    console.log(person1.introduce());  // Expected output: "Hi, I'm Alice Johnson, and I'm 30 years old."

                // ---------------------------------- Task 5 ---------------------------------- //
                    /* DESCRIPTION:
                    Create an interface `Animal` with the following properties:
                      - `name`: a string.
                      - `sound`: a string.
                    Create a class `Dog` that implements the `Animal` interface and includes a method `speak()`
                    that returns a string using the `sound` property.
                    */

                    // YOUR CODE HERE


                    // TEST
                    const dog1 = new Dog("Buddy", "woof");
                    console.log(dog1.speak());  // Expected output: "Buddy says woof!"

                // ---------------------------------- Task 6 ---------------------------------- //
                    /* DESCRIPTION:
                    Create an interface `Employee` with the following properties:
                      - `name`: a string.
                      - `position`: a string.
                      - `salary`: a number.
                    Create a class `Manager` that implements the `Employee` interface and includes a method `getDetails()`
                    that returns a string with the employee's details.
                    */

                    // YOUR CODE HERE


                    // TEST
                    const manager1 = new Manager("Sarah", "Project Manager", 75000);
                    console.log(manager1.getDetails());  // Expected output: "Sarah is a Project Manager and earns $75000 annually."

            </code></pre>
        </dl>
    </section>
</section>


<section class="disclaimer" data-background="../../../outfit/images/for_slides/the_end_on_sand.jpg">
     <p>These slides are based on</p>
     <p>customized version of </p>
     <p><a href="http://hakim.se/">Hakimel</a>'s <a href="http://lab.hakim.se/reveal-js">reveal.js</a></p>
     <p>framework</p>
</section>
<!--
########################################################
##################### SLIDES END   #####################
########################################################
-->
        </div>
    </div>
    <!-- Custom processing -->
    <script src="../../../outfit/js/slides.js"></script>
    <!-- external scripts -->
    <script src="../../../lib/reveal.js/dist/reveal.js"></script>
    <script src="../../../lib/reveal.js/plugin/zoom/zoom.js"></script>
    <script src="../../../lib/reveal.js/plugin/notes/notes.js"></script>
    <script src="../../../lib/reveal.js/plugin/search/search.js"></script>
    <script src="../../../lib/reveal.js/plugin/markdown/markdown.js"></script>
    <script src="../../../lib/reveal.js/plugin/highlight/highlight.js"></script>


    <!-- init reveal -->
    <script>
        // Full list of configuration options available at:
        // https://github.com/hakimel/reveal.js#configuration
        // var highlightjsTabSize = '  ';
        Reveal.initialize({

            slideNumber: 'c/t',
            keyboard: true,
            history: true,
            center: true,
            width: 1920,
            height: 1080,
            // slide transition
            transition: 'concave', // none/fade/slide/convex/concave/zoom
            // Factor of the display size that should remain empty around the content
            margin: 0.1,
            // shift+mousе click to zoom in/out element
            zoomKey: 'ctrl',
            // theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
            // transition: Reveal.getQueryHash().transition || 'default'

            plugins: [ RevealZoom, RevealNotes, RevealSearch, RevealMarkdown, RevealHighlight ]
        });
    </script>
</body>
</html>
